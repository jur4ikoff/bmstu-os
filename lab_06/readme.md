## Seminar
когда загрузили демон он работает показать его в системе и прокомметировать все позиции каждый столбец инфмаорция которая выдает команда ps
что такое прерываемый --- S, какой сон прервать нельзя --- D
очевидные вопросы:
правила программирования демона
sigaction
определение полей struct sigaction
pthread_create pthread_sigmask

набор 2
есть функция reread она пустая надо написать про конф файлы и директорию где он находится
обьяснить почему нужны права суперюзера
там где sigterm завершать только поток вызывать pthread_exit() основной поток продолжает работать завершить kill -9
убить какого то демона типо kthread_daemon либо любого другого который инсталлируется при загрузке системы

## Флаги
### S - Сон
#### Какой сон?
Сон в оидании завершения

### s - session leader

### l - многопоточный

## ps -ajx
процесс является лидером сессии, поэтому 3 одиинаковх числа в pid

## Какие изменения мы внесли в ЛР
Мы добавили флаг E_XCL

### E_XCL
Если файл существует, то системный вызов open завершится с ошикой, поэтому программа завершится на exit и не дойдет до вызова `fcntl` 


## По коду
`umask(0);` --- Сбрасывает маску создания файлов  

Получаем максимальное число открытых файловых дескрипторов для этого процесса.
```c
	if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
	{
		perror("getrlimit");
		exit(1);
	}
```


Готовим обработчик сигнала: игнорировать SIGHUP.  
SIGHUP — сигнал, посылаемый процессу для уведомления о потере соединения с управляющим терминалом пользователя.
```c
sa.sa_handler = SIG_IGN;
sigemptyset(&sa.sa_mask);
sa.sa_flags = 0;
```


Игнорируем `SIGHUP` — на случай, если терминал     
Системный вызов `sigaction` используется для изменения действий процесса при получении соответствующего сигнала.
```c
	if (sigaction(SIGHUP, &sa, NULL) == -1)
	{
		printf("sigaction, errno %d", errno);
		exit(1);
	}
```

Создаём новую сессию, становимся её лидером, отвязываемся от управляющего терминала.
```c
	if (setsid() == -1)
	{
		printf("setsid, errno %d", errno);
		exit(1);
	}
```

Меняем рабочую директорию на корень, чтобы не мешать размонтированию ФС  
```c
	if (chdir("/") == -1)
	{
		printf("chdir, errno %d", errno);
		exit(1);
	}
```

Если лимит "бесконечен" — ограничиваем разумным значением (1024 — достаточно для большинства случаев).  
```c
if (rl.rlim_max == RLIM_INFINITY)
	{
		rl.rlim_max = 1024;
    }
```

Закрываем все возможные файловые дескрипторы (stdin, stdout, stderr, сокеты и т.д.).
```c
	for (i = 0; i < rl.rlim_max; i++)
	{
		close(i);
	}
```

Открываем /dev/null → дескриптор fd0 (обычно 0, но не гарантировано).  
dup(0) создаёт копию дескриптора 0 → fd1 и fd2 будут равны новым номерам.  
❗ Ошибка: не гарантируется, что fd1 == 1, fd2 == 2. Лучше:  
```c
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(0);
	fd2 = dup(0);
```

Поток. Бесконечно ждём сигнал из множества mask. sigwait() атомарно достаёт сигнал.
```c
void *thr_fn(void *arg)
{
	int signo;

	for (;;)
	{
		if (sigwait(&mask, &signo) != 0)
		{
			syslog(LOG_ERR, "sigwait, errno %d", errno);
			pthread_exit(0);
		}
```

```c
	sa.sa_handler = SIG_DFL; // SIG_DFL обработчик сигнала по умолчанию (установления системы)
	sigemptyset(&sa.sa_mask); // Cбрасывается маска множества сигналов, которые будут заблокированы
	sa.sa_flags = 0; // Сбрасывает фалг специального поведения
```

```c
if (sigfillset(&mask) == -1) // Наполняем mask всеми сигналами по умолчанию.
{
    syslog(LOG_ERR, "sigfillset");
    exit(1);
}

// SIG_BLOCK -- объединение текущей сигнальной маски с переданной
if ((err = pthread_sigmask(SIG_BLOCK, &mask, NULL)) == -1) // Где в коде видно, что демон принимает все сигналы
{
    syslog(LOG_ERR, "pthread_sigmask"); 
    exit(1);
}
```

# МБ нужно поменять
`fl.l_type = F_WRLCK | F_RDLCK;`

## Вопрос: Опишите все что происходит в main:
**Ответ:**
1. Инициализируем структуру sigaction, которая описывает поведения при обработки
сигналов. Присваиваем хендлеру сигнал SIG_DFL, который означает то что, устанавливается реакция по умолчанию
2. sigemptyset Cбрасывается маска множества сигналов, которые будут заблокированы (sa_mask).
3. flags = 0 сброс флагов специального поведения
4. В sigaction определяем поведение для sighup
5. sigfillset - заполняем маску сигналов(лучше посмотрите определение из документации с сайта oracle - The sigfillset() function initializes the set pointed to by set to include all signals defined by the system.), а потом определяем поведение потока.

## Вопрос: Что значит SIG_BLOCK ?
Ответ: Объединение сигнальной маски.

## Вопрос: Объяснить, почему три одинаковых идентификатора является лидером группы, сессии,
находится там один.
Ответ: Потому что демон становится лидером новой группы процессов и новой сессии, и в этой
группе/сессии он единственный.
## Вопрос: Объяснить ppid.

Ответ: Усыновлён процессом-посредником, потому что демон запущен из терминала.

## Вопрос: Объяснить -1 и ?.
Ответ: Нет управляющего терминала, нет терминальной группы.