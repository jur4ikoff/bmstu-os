\section{Пересчёт динамических приоритетов}

При создании процесса ему назначается приоритет. В ОС семейства 
UNIX и в ОС семейства Windows 
пересчитываться могут только приоритеты 
пользовательских процессов.

\subsection{UNIX/Linux}

В классическом UNIX ядро является строго не вытесняемым --- процесс в режиме ядра не может быть вытеснен другим более приоритетным процессом. В современных UNIX-подобных системах (в частности, Linux) ядро является вытесняемым (preemptive). Это означает, что процесс, выполняющийся в режиме ядра, может быть прерван, если появился более приоритетный процесс, готовый к исполнению. Вытесняемое ядро позволяет системе эффективно обслуживать процессы реального времени.

\subsubsection{Приоритеты процессов}

\textbf{Традиционный подход (BSD / System V)}

Очередь готовых к выполнению процессов формируется в соответствии с приоритетами и принципом вытесняющего циклического планирования. Приоритет в традиционном UNIX задается целым числом в диапазоне от 0 до 127. Чем меньше значение, тем выше приоритет процесса.

\begin{itemize}
    \item 0 -- 49: Зарезервированы для процессов ядра (статические приоритеты).
    \item 50 -- 127: Предназначаются прикладным процессам (динамические приоритеты).
\end{itemize}

В дескрипторе процесса \textbf{proc} содержатся поля:
\begin{itemize}
    \item \textbf{p\_pri} --- текущий приоритет планирования;
    \item \textbf{p\_usrpri} --- приоритет процесса в режиме задачи;
    \item \textbf{p\_cpu} --- результат последнего измерения степени загруженности процессора;
    \item \textbf{p\_nice} --- фактор любезности (0--39, по умолчанию 20).
\end{itemize}

Каждую секунду обработчик таймера запускает процедуру \textbf{schedcpy}, которая 
пересчитывает приоритеты, используя формулу полураспада (decay):
$$
decay = \frac{2 \cdot load\_average}{2 \cdot load\_average + 1}
$$
Приоритет пересчитывается как:
$$
p\_usrpri = PUSER + \frac{p\_cpu}{4}+ 2 \cdot p\_nice
$$
Данная схема предотвращает бесконечное откладывание низкоприоритетных процессов, повышая приоритет тех, кто долго ждал.

Также существует таблица приоритетов сна (для систем 4.3 BSD), которая определяет приоритет процесса после пробуждения (Таблица~\ref{tab:sleep_pri}).

\begin{table}[H]
	\caption{Приоритеты сна в операционных системах 4.3~BSD и SCO UNIX}
	\centering
	\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}X|c|c|}
		\hline
		\textbf{Событие} & \textbf{Приоритет 4.3~BSD} & \textbf{Приоритет SCO UNIX} \\
		\hline
		Ожидание загрузки в память & 0 & 95 \\
		\hline
		Ожидание ввода-вывода & 20 & 81 \\
		\hline
		Ожидание буфера & 30 & 80 \\
		\hline
		Низкоприоритетное состояние сна & 40 & 66 \\
		\hline
	\end{tabularx}
	\label{tab:sleep_pri}
\end{table}

\textbf{Linux}

В отличие от BSD, в Linux используется единая шкала приоритетов от \textbf{0 до 139}.

Меньшее значение всё так же означает более высокий приоритет. Эта шкала объединяет задачи 
реального времени и обычные задачи.

\begin{itemize}
    \item \textbf{0 -- 99 (Real-Time):} Приоритеты реального времени. Чем выше число, тем ниже приоритет. Задачи из этого диапазона всегда вытесняют задачи из диапазона 100--139.
    \item \textbf{100 -- 139 (Normal):} Обычные процессы. Этот диапазон проецируется на значения \textbf{nice} от -20 до +19.
\end{itemize}


\subsubsection{Потоки POSIX}
В современном UNIX потоки являются единицей диспетчеризации.
Для назначения приоритетов потокам используется три класса планирования. \\
\textbf{Классы планирования}:
\begin{itemize}
    \item Deadline: Имеет наивысший приоритет. Используется для задач с жёсткими временными ограничениями;
    \item Real-Time: Второй по приоритету класс, предназначен для задач реального времени;
    \item Fair: Предназначен для прикладных задач.
\end{itemize}


Согласно технической документации ядра Linux, планировщик не различает процессы и потоки. 
Основной единицей планирования является \textbf{Задача (Task)}, описываемая 
структурой \texttt{task\_struct}. Процесс рассматривается 
как группа задач, разделяющих общие ресурсы.

В дескрипторе \texttt{task\_struct} хранятся поля, определяющие приоритет задачи:
\begin{itemize}
    \item \texttt{static\_prio} --- статический приоритет. Используется для обычных задач (normal tasks) и зависит от значения \texttt{nice}. Диапазон значений: 100--139. Не влияет на задачи реального времени;
    \item \texttt{rt\_priority} --- приоритет реального времени. Используется только для RT-задач. Диапазон: 0--99. Игнорируется для обычных задач;
    \item \texttt{normal\_prio} --- приоритет задачи без учета временных повышений (бустинга) со стороны ядра. 
    \begin{itemize}
        \item Для обычных задач он равен \texttt{static\_prio}.
        \item Для задач реального времени он вычисляется на основе \texttt{rt\_priority}.
    \end{itemize}
    \item \texttt{prio} --- эффективный приоритет, который непосредственно используется планировщиком для принятия решений. Обычно совпадает с \texttt{normal\_prio}, но может быть временно изменен ядром (например, при использовании мьютексов с наследованием приоритетов).
\end{itemize}

\img{70pt}{pr.png}{Диапазон приоритетов, используемый ядром Linux}

Каждой задаче назначается алгоритм планирования, 
который определяет алгоритм диспетчеризации. В Таблице~\ref{tab:linux_policies} 
приведены основные политики.

\begin{table}[H]
	\small
	\caption{Политики планирования и приоритеты в Linux}
	\centering
	\begin{tabularx}{\textwidth}{|l|X|c|}
		\hline
		\textbf{Политика} & \textbf{Краткое описание} & \textbf{Приоритет} \\
		\hline
		\textbf{SCHED\_DEADLINE} & Алгоритм GEDF. Строгое соблюдение дедлайнов. & -1 \\
		\hline
		\textbf{SCHED\_FIFO} & Реальное время (FIFO). Без квантования, до явной отдачи ресурса. & 0 -- 99 \\
		\hline
		\textbf{SCHED\_RR} & Реальное время (Round Robin). С квантованием времени. & 0 -- 99 \\
		\hline
		\textbf{SCHED\_OTHER} & Стандартная политика для обычных процессов. & 100 -- 139 \\
		\hline
		\textbf{SCHED\_BATCH} & Пакетная обработка (низкая интерактивность). & 100 -- 139 \\
		\hline
		\textbf{SCHED\_IDLE} & Фоновые задачи (запуск только при простое CPU). & 139 \\
		\hline
	\end{tabularx}
	\label{tab:linux_policies}
\end{table}

\textbf{Пересчет приоритетов}

В ядре Linux определена константа \texttt{MAX\_RT\_PRIO}, равная 100. Это значение разделяет шкалу на приоритеты реального времени и обычные приоритеты. В отсутствие временного повышения (бустинга), эффективный приоритет (\texttt{prio}) рассчитывается следующим образом:

1. \textbf{Задачи реального времени (RT):}
Для них эффективный приоритет вычисляется на основе поля \texttt{rt\_priority} по формуле:
$$
prio = normal\_prio = MAX\_RT\_PRIO - 1 - rt\_priority
$$
Таким образом, высокое значение \texttt{rt\_priority} (например, 99) превращается в низкое числовое значение приоритета ядра (0), что означает наивысший приоритет.

2. \textbf{Обычные задачи (Normal):}
Для них приоритет определяется полем \texttt{static\_prio}, которое зависит от значения \texttt{nice} $\in [-20; 19]$:
$$
static\_prio = 120 + nice
$$
В данном случае эффективный приоритет равен статическому:
$$
prio = normal\_prio = static\_prio
$$
\textbf{Алгоритмы планирования:}
\begin{itemize}
    \item \textbf{Completely Fair Scheduler (CFS):} Обеспечивал равномерное распределение времени, моделируя «идеальный многозадачный процессор» через красно-черное дерево (до ядра 6.6).
    \item \textbf{Earliest Eligible Virtual Deadline First (EEVDF):} Заменил CFS в 2023 году. Алгоритм вводит понятие «лага» (lag) — разницы между тем, сколько времени задача должна была получить, и сколько получила реально. Планировщик выбирает задачи с дедлайнами, чтобы поддерживать лаг около нуля, снижая задержки.
\end{itemize}

Все современные unix системы являеются многопоточными. 

\textbf{Реализация многопоточности POSIX Threads}

Все современные UNIX-системы являются многопоточными. Для переносимости ПО был разработан стандарт \textbf{POSIX.1c} (POSIX Threads, pthreads).

В операционной системе Linux стандарт POSIX Threads реализуется библиотекой 
\textbf{NPTL} (Native POSIX Thread Library). Согласно официальной документации Linux, 
эта реализация использует модель потоков <<один-к-одному>> (1:1). 
Это означает, что:
\begin{itemize}
    \item Каждый поток пространства пользователя (user-space thread), созданный функцией \texttt{pthread\_create}, 
    напрямую отображается на одну сущность планирования ядра (kernel scheduling entity, KSE).
    \item В Linux каждая такая сущность описывается структурой \texttt{task\_struct} и создается 
    с помощью системного вызова \texttt{clone()} с флагом \texttt{CLONE\_THREAD}.
    \item Ядро операционной системы управляет каждым потоком индивидуально, что позволяет 
    эффективно использовать многопроцессорные системы (SMP), распределяя потоки одного процесса по разным ядрам CPU.
    \item Потоки разделяют общие ресурсы, но обладают уникальным идентификатором потока внутри ядра.
\end{itemize}

Благодаря модели 1:1, планировщик Linux (CFS или EEVDF) может 
эффективно распределять потоки одного многопоточного 
приложения по разным ядрам процессора, обеспечивая параллелизм.


\subsection{Windows}

В ОС семейства Windows процессу при создании присваивается приоритет процесса. Данный приоритет является базовым для потока.
Относительно базового приоритета высчитывается относительный приоритет. Единицей диспетчеризации является поток. 
Планирование
осуществляется на основе приоритетов потоков, готовых к выполнению. Потоки с более низким
приоритетом могут быть вытеснены потоками с более высокими приоритетами, когда те будут
готовы к выполнению. По истечению кванта времени текущего потока, ресурс передается
самому приоритетному потоку в очереди готовых к выполнению.


В ОС семейства Windows существует 32 уровня приоритета:
\begin{itemize}
    \item от 0 до 15 --- изменяющиеся уровни (уровень 0 зарезервирован для потока обнуления
страниц);
    \item от 16 до 31 --- уровни реального времени.
\end{itemize}

Система не повышает приоритет потоков с базовым уровнем приоритета от 16 до 31.
Только потоки с базовым приоритетом от 0 до 15 получают динамический приоритет.

Уровни приоритета потоков назначаются с двух позиций: Windows API и ядра
операционной системы. Windows API сортирует процессы по классам приоритета, которые
были назначены при их создании:
\begin{itemize}
    \item реального времени (real-time, 4);
    \item высокий (high, 3);
    \item выше обычного (above normal, 6);
    \item обычный (normal, 2);
    \item ниже обычного (below normal, 5);
    \item простой (idle, 1).
\end{itemize}

Функция \textbf{SetPriorityClass} позволяет изменять класс приоритета процесса до одного из
этих уровней.

Затем назначается относительный приоритет потоков в рамках процессов:
\begin{itemize}
    \item критичный по времени (time critical, 15);
    \item наивысший (highest, 2);
    \item выше обычного (above normal, 1);
    \item обычный (normal, 0);
    \item ниже обычного (below normal, -1);
    \item низший (lowest, -2);
    \item  простой (idle, -15).
\end{itemize}

Исходный базовый приоритет потока наследуется от базового приоритета процесса. Процесс по умолчанию наследует свой базовый приоритет у того процесса, который его создал.

Таким образом, в Windows API каждый поток имеет базовый приоритет, являющийся
функцией класса приоритета процесса и его относительного приоритета процесса. В ядре класс
приоритета процесса преобразуется в базовый приоритет. В таблице~\ref{tab:win_kernel_api} приведено соответствие
между приоритетами Windows API и ядра системы приоритета.

\newcolumntype{C}{>{\centering\arraybackslash}X}
\begin{table}[H]
    \caption{Соответствие между приоритетами Windows API и ядра Windows}
    \centering
    \small
    \begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}X|*{6}{C|}}
        \hline
        & \textbf{real-time} & \textbf{high} & \textbf{above normal} & \textbf{normal} & \textbf{below normal} & \textbf{idle} \\
        \hline
        \textbf{time critical} & 31 & 15 & 15 & 15 & 15 & 15 \\
        \hline
        \textbf{highest}       & 26 & 15 & 12 & 10 & 8  & 6  \\
        \hline
        \textbf{above normal}  & 25 & 14 & 11 & 9  & 7  & 5  \\
        \hline
        \textbf{normal}        & 24 & 13 & 10 & 8  & 6  & 4  \\
        \hline
        \textbf{below normal}  & 23 & 12 & 9  & 7  & 5  & 3  \\
        \hline
        \textbf{lowest}        & 22 & 11 & 8  & 6  & 4  & 2  \\
        \hline
        \textbf{idle}          & 16 & 1  & 1  & 1  & 1  & 1  \\
        \hline
    \end{tabularx}
    \label{tab:win_kernel_api}
\end{table}


В Windows также включен диспетчер настройки баланса, который сканирует очередь
готовых процессов 1 раз в секунду. Если он обнаруживает потоки, ожидающие выполнения
более 4 секунд, диспетчер настройки баланса повышает их приоритет до 15. Когда истекает
квант, приоритет потока снижается до базового приоритета. Если поток не был завершен за
квант времени или был вытеснен потоком с более высоким приоритетом, то после снижения
приоритета поток возвращается в очередь готовых потоков.

Текущий приоритет потока в динамическом диапазоне (от 1 до 15) может быть изменён
планировщиком вследствие следующих причин:
\begin{itemize}
    \item повышение приоритета после завершения операций ввода-вывода (см. таблицу~\ref{tab:pri_incr});
    \item повышение приоритета на 1 при завершении ожидания на семафоре, мьютексе или событии;
    \item повышение приоритета на 2 для потоков-владельцев окон при их активации;
    \item повышение приоритета владельца блокировки (для предотвращения инверсии приоритетов);
    \item повышение приоритета вследствие длительного ожидания ресурса исполняющей системы;
    \item повышение приоритета в случае, когда готовый к выполнению поток не был запущен
в течение длительного времени (защита от голодания);
    \item повышение приоритета проигрывания мультимедиа службой планировщика \textbf{MMCSS}.
\end{itemize}

Текущий приоритет потока в динамическом диапазоне может быть понижен до базового
путем вычитания всех его повышений. В таблице~\ref{tab:pri_incr} приведены рекомендуемые значения
повышения приоритета для устройств ввода-вывода.

\begin{table}[H]
    \caption{Рекомендуемые значения повышения приоритета}
    \centering
    \begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}X|c|}
        \hline
        \textbf{Устройство} & \textbf{Повышение приоритета} \\
        \hline
        Жесткий диск, привод компакт-дисков, параллельный порт, видеоустройство & 1 \\
        \hline
        Сеть, почтовый слот, именованный канал, последовательный порт & 2 \\
        \hline
        Клавиатура, мышь & 6 \\
        \hline
        Звуковая плата & 8 \\
        \hline
    \end{tabularx}
    \label{tab:pri_incr}
\end{table}


Потоки, на которых выполняются различные мультимедийные приложения, должны
выполняться с минимальными задержками. В Windows эта задача решается путем повышения
приоритетов таких потоков драйвером \textbf{MMCSS} --- MultiMedia Class Scheduler Service.
Приложения, которые реализуют воспроизведение мультимедиа, указывают драйверу \textbf{MMCSS}
задачу из списка:
\begin{itemize}
    \item аудио;
    \item игры;
    \item распределение;
    \item захват;
    \item воспроизведение;
    \item задачи администратора многоэкранного режима.
\end{itemize}

Функции драйвера MMCSS временно повышают приоритет потоков, зарегистрированных MMCSS до уровня, который соответствует категории планирования. Потом их приоритет снижается до уровня, соответствующего категории планирования Exhausted, для того, чтобы другие потоки могли также получить ресурс.


\subsubsection{Уровень запроса прерывания (IRQL)}

Windows устанавливает свою собственную схему приоритетности прерываний,
известную как IRQL. В ядре IRQL уровни представлены в виде номеров от 0 до 31 на
системах x86 и в виде номеров от 0 до 15 на системах x64 и IA64, где более высоким номерам
соответствуют прерывания с более высоким приоритетом. На рисунках~\ref{img:irq_x86.png} показаны IRQL
для архитектур x86, x64 и IA64 соответственно.


\img{150pt}{irq_x86.png}{Уровни запросов прерываний для архитектуры x86}

