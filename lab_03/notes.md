# Оси3
## Определения

**Процесс** — Программа, выполняющаяся в отдельном адресном пространстве

**fork() — системный вызов, который создаёт новый процесс — процесс-потомок, который является копией процесса-предка. Он наследует дескрипторы всех открытых файлов, сигнальную маску, маску режима создания файлов и т. п. Для этого процесса создаётся собственное адресное пространство, т. е. создаются ТАБЛИЦЫ СТРАНИЦ и дескрипторы СТРАНИЦ потомка ссылаются на СТРАНИЦЫ адресного пространства предка, И для страниц адресного пространства предка права доступа МЕНЯЮТСЯ на only-read и УСТАНАВЛИВАЕТСЯ флаг copy-on-write. В результате, если или предок, или потомок попытаются изменить какую-либо страницу, возникнет исключение по правам доступа, И операционная система, обрабатывая это исключение, ОБНАРУЖИТ УСТАНОВЛЕННЫЙ флаг copy-on-write и создаст копию страницы в адресном пространстве того процесса, который пытался её изменить, И такая ситуация будет существовать в системе до тех пор, пока процесс-потомок не вызовет exec() или exit(), И в результате страницам адресного пространства предка возвращаются обычные права доступа страниц, и флаг copy-on-write сбрасывается.**

отголосок этого флага в ps -al fork but not exec. У потомков это 1 (fork but not exec)

**exit()** --- системный вызов, который завершает процесс

**exec() — системный вызов, который переводит процесс на адресное пространство программы, которая была передана ему в качестве параметра**
1) проверяет, существует ли файл с именем, которое ему передали;
2) проверяет, есть ли у процесса, который выполняет системный вызов exec, права на его запуск;
3) проверяет, исполняемый ли он (~для этого надо прочитать заголовок файла~);
4) создаётся новое адресное пространство, т.е. создаются таблицы страниц для программы, переданной exec в качестве параметра;
5) удалить старые таблицы страниц, указатель на которые содержится в дескрипторе процесса;
6) поменять указатель на новые таблицы страниц;
7) загрузить в счетчик команд (регистр IP) на точку входа программы (начальный адрес программы) (~или адрес точки входа программы, или просто точку входа программы~), а в регистр CR3 загрузить адрес таблиц страниц из дескриптора процесса (в дескрипторе мы поменяли адрес таблиц страниц, но его ещё надо загрузить в CR3), чтобы можно было выполнять страничное преобразование, которое нужно для адресации кода.

**pipe()** —— системный вызов, который создаёт неименованный программный канал

## Пункт 3
### 1. Если закоментить exit внутри форка
Что нужно ответить: что изза того что закоментирован экзит выполняется системный вызов fork в childе. Это приводит к созданию новых childов

### 2. Что происходит в 3 программе
создается потомок, вызывает ехек, теряет квант, продолжает работать предок, создает потомка 2, он вызывает ехек, теряет квант, и первый потомок печатает приглашение к вводу и блокируется в ожидании завершения ввода

### Что происходит в 4 программе
процесс 1 написал в ріре, процесс 2 написал в ріре, родительский
процесс считал все из ріре, последняя строка показывает, что труба пуста, передача

#### Где создаётся канал?
Канал создаётся в области данных ядра

#### Почему он создаётся там?
Так как адресное пространство процесса ЗАЩИЩЁННОЕ, ни один процесс не может обратиться в адресное пространство другого процесса, единственный способ обмена данными между процессами — через третье адресное пространство

### Pipe
### Какая модель передачи данных
**попотокавая** - значит, что после чтения из пайпа сообщение перестает существовать
симплексна и дуплексная

Для справки:
1) Системный вызов pipe: что создаётся и для чего, особенности.

Системный вызов pipe создает неименованный программный канал.
Программный канал - буфер типа FIFO в области данных ОС.

# Сигналы

**Сигналы** — программное средство с помощью которого процессы UNIX информируются о событиях, как в системе, так и в самом процессе. ТЕ сигналы связааны с определенными событиями. Если это внешнее по отношение к событию, то это ассинхронное событие для процесса, то есть это независимые от того, что процесс выполнет. События, которые происходят внутри процесса, являются синхронными. Как правило получение проессом сигнала указывает ему на необходимость завершиться. Но для систем

Inter Process Communicatopn
1. Сигналы
2. Семафоры
3. Программеые каналы именованные и неименованные
4. Системы разделемой памяти
5. Очереди сообщений 

### POSIX 1 FIPC (Federal Information Processing Standart)
- [ ] `NSIG` 20
- [ ] `SIGHUP` 1 - сообщает, что разорвана связь с терминалом
- [ ] `SIGINT` 2 — ctrl + c
- [ ] `SIGQUIT` 3 — ctrl + \ 
- [ ] `SIGKILL` 9 — KILL
- [ ] `SIGBUS` 10 — 
- [ ] `SIGSEGV` 11 — Ошибка адрессация / выход за пределы сегмента 
- [ ] `STGPIPE` 13 — сигнал возникает, если запись в канал есть, а чтоения нет, тоесть нет процесс
- [ ] `SIGALARM` 14 — Висит на таймере
- [ ] `SIGTERM` 15 — _
- [ ] `SIGUSR1` 16
- [ ] `SIGUSR2` 17
- [ ] `SIGCLD` 18 - Сокращение cld = child, Получает процесс предок при завершении процесса потомка
- [ ] `SIGPWR` 19 - Возникает при сбое питания
- [ ] `SIGPOOL` 22 — События  в string н-ыу

### Макросы
- [ ] `SIG_DFL`(int(*)(|)) void
- [ ] `SIG_IGN`(int(*)(|)) 1. 



<br></br>
Средством посылки и восприятия сигнала в unix служат два системных вызова. kill и signal
```c
int kill(int pid int sig);
// Если pid = идентификатору прцессу, тогда сигнал kill получат все процессы данной группы
// Если pid <= 1 ...
// Если pid != 0 ...

kill(getpid(), SIGALARM);
```

```c
#include <signal.h>

typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);

// "Абсурдный экзампл, сигнал по старому обработчику"
#include <signal.h>
int main()
{
    void (*old_handler)(int) = signal(SIGINT, SIG_IGN);
    signal(SIGINT, old_handler)
}
```
```c
struct sigaction {
    void (*sa_handler)(int);
    void (*sa_sigaction)(int, siginfo_t *, void *);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
}

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```
Все кратно размеру страни, деление на сегменты очень удобное не просто так было введено, поскольк есть действ.... Есть статические данные, есть куча, есть стек. Мы видим сигнал SIGSEV контроль с целью защиты адрессного пространства процесса. Ни один процесс не можеь обратиться в адрессное пространство другого процесса. 

Если к ядру очередь пуста, то перетащить к себе процесс из другой очереди. 

Почему все держится на иерархии процессов,


## ВОПРОСЫ НА 5 ПУНКТ
### Зачем мы обрабатываем сигнал
Чтоб изменить ход выполнения программы

### Как мы меняем ход выполнения программы
За счет изменения флага

### Как вы устанавливаете сигнал
С помощью системного вызова сигнал

### Что за сигнал
Указанный сигнал SIGINT, вызывается, когда нажимается CTRL + C, в результате прерывания от клавы


### Что делают сигналы
сигналы - меня способ выпонения прогаммы
какой алгоритм реализован в программе - ветвление по флагу


